from ACSLowLevel import *

ASTBitDesignators = {
    0:'#LEAD',
    3:'#DC',
    4:'#PEGREADY',
    5:'#MOVE',
    6: '#ACC',
    7:'#BUILDUP',
    8:'#VELLOCK',
    9:'#POSLOCK',
    11:'#TRIGGER',
    16:'#NEWSEGM',
    17:'#STARV',
    18:'#ENCWARN',
    19:'#ENC2WARN',
    20:'#INRANGE',
    21:'#LCTICKLE',
    22:'#LCMODUL',
    23:'#FOLLOWED',
    24:'#HOLD',
    25:'#INHOMING',
    26:'#DECOMPON',
    27:'#INSHAPE',
    29:'ENCPROC'
}
ASTBitSignificance = {
    '#LEAD': '1 = axis is leading in a group',
    '#DC': '1 = Axis data collection is in progress',
    '#PEGREADY': '1 = all values are loaded and the Incremental/Random PEG is ready to respond to movement. When referring to this bit, axis_index designates the PEG engine rather than the axis.',
    '#MOVE': '1 = Axis is involved in a motion',
    '#ACC': '1 = Axis in accelerating motion state',
    '#BUILDUP': '1 = Segments build-up',
    '#VELLOCK': '1 = Slave is synchronized to master in velocity lock mode - slave velocity strictly follows the master velocity.',
    '#POSLOCK': '1 = Slave is synchronized to master in position lock mode - slave position strictly follows the master position.',
    '#TRIGGER': '1 = Produces an interrupt to the host application, enabled by IENA.26',
    '#NEWSEGM': 'The controller sets the bit to inform that a new segment is required to be provided by the application. The bit is set starvation_margin ms before the starvation condition occurs. The starvation condition is indicated by #STARV bit',
    '#STARV': 'The controller sets the bit to indicate starvation condition. The starvation condition means that there are not enough further segments to continue the motion with required velocity. In this case, the controller starts decelerating the motion with Â½ JERK in order to prevent motion discontinuity and avoid mechanical jerks. Once the application begins supplying segments at a sufficient rate, the controller returns the motion back to normal condition. Note, that often the starvation condition causes inefficient velocity generation and increases the time required for completing the required motion path.',
    '#ENCWARN': 'Indicates if there is an encoder warning. Cleared by the ACSPL+ FCLEAR command.',
    '#ENC2WARN': 'Indicates if there is an secondary encoder warning. Cleared by the ACSPL+ FCLEAR command.',
    '#INRANGE': 'Laser In Range',
    '#LCTICKLE': '0: tickle mode is off 1: tickle mode is active',
    '#LCMODUL': '0: modulation is off 1: modulation is active',
    '#FOLLOWED': '0: Axis in regular mode 1: Axis in slave mode and follows the profile generated by RTC6',
    '#HOLD': '0: hold is off 1: hold is in progress',
    '#INHOMING': '0: homing is not in process 1: homing is in process',
    '#DECOMPON': 'The bit is set to 0 in the following cases: > Calling ERRORMAPOFF function > Calling ERRORUNMAP function (in case there are no other active dynamic error compensation zones of the specified axis) > During homing process initiated by HOME command (switched ON back at the end of the process > Encoder Error / Encoder Not Connected faults > Changing one of the encoder-related parameters (E_TYPE, E_FREQ, E_SCMUL, SLPBITS, E_AOFSS) > Changing encoder routing (SLPROUT)',
    '#INSHAPE': '0: Input Shaping not Active 1: Input Shaping Active',
    '#ENCPROC': '0: Encoder Initialization not in process 1: Encoder Initialization in process'
}

def qAST(axis, bitdesignator):
    writeToACS(f'?AST({axis}).{bitdesignator}')
    status = recvall(1024)
    print(ASTBitDesignators[5])
    return status[9]

def qASTBitDesignator(bitdesignator):
    if type(bitdesignator) == type(0):
        try:
            print(ASTBitDesignators.get(bitdesignator))
        except:
            print(f"No documentation for AST bit {bitdesignator} is available.")
    elif type(bitdesignator) == type("X"):
        try:
            AST





